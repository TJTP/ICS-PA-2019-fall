
./build/x86-nemu/tests/add.o:     file format elf32-i386


Disassembly of section .text:

00000000 <nemu_assert>:

#include <am.h>
#include <klib.h>

__attribute__((noinline))
void nemu_assert(int cond) {
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 08             	sub    $0x8,%esp
  if (!cond) _halt(1);
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	85 c0                	test   %eax,%eax
   b:	74 02                	je     f <nemu_assert+0xf>
}
   d:	c9                   	leave  
   e:	c3                   	ret    
  if (!cond) _halt(1);
   f:	83 ec 0c             	sub    $0xc,%esp
  12:	6a 01                	push   $0x1
  14:	e8 fc ff ff ff       	call   15 <nemu_assert+0x15>
  19:	8d 76 00             	lea    0x0(%esi),%esi

0000001c <add>:
#include "trap.h"

int add(int a, int b) {
  1c:	55                   	push   %ebp
  1d:	89 e5                	mov    %esp,%ebp
	int c = a + b;
  1f:	8b 45 0c             	mov    0xc(%ebp),%eax
  22:	03 45 08             	add    0x8(%ebp),%eax
	return c;
}
  25:	5d                   	pop    %ebp
  26:	c3                   	ret    

Disassembly of section .text.startup:

00000000 <main>:
int test_data[] = {0, 1, 2, 0x7fffffff, 0x80000000, 0x80000001, 0xfffffffe, 0xffffffff};
int ans[] = {0, 0x1, 0x2, 0x7fffffff, 0x80000000, 0x80000001, 0xfffffffe, 0xffffffff, 0x1, 0x2, 0x3, 0x80000000, 0x80000001, 0x80000002, 0xffffffff, 0, 0x2, 0x3, 0x4, 0x80000001, 0x80000002, 0x80000003, 0, 0x1, 0x7fffffff, 0x80000000, 0x80000001, 0xfffffffe, 0xffffffff, 0, 0x7ffffffd, 0x7ffffffe, 0x80000000, 0x80000001, 0x80000002, 0xffffffff, 0, 0x1, 0x7ffffffe, 0x7fffffff, 0x80000001, 0x80000002, 0x80000003, 0, 0x1, 0x2, 0x7fffffff, 0x80000000, 0xfffffffe, 0xffffffff, 0, 0x7ffffffd, 0x7ffffffe, 0x7fffffff, 0xfffffffc, 0xfffffffd, 0xffffffff, 0, 0x1, 0x7ffffffe, 0x7fffffff, 0x80000000, 0xfffffffd, 0xfffffffe};

#define NR_DATA (sizeof(test_data) / sizeof(test_data[0]))

int main() {
   0:	8d 4c 24 04          	lea    0x4(%esp),%ecx
   4:	83 e4 f0             	and    $0xfffffff0,%esp
   7:	ff 71 fc             	pushl  -0x4(%ecx)
   a:	55                   	push   %ebp
   b:	89 e5                	mov    %esp,%ebp
   d:	57                   	push   %edi
   e:	56                   	push   %esi
   f:	53                   	push   %ebx
  10:	51                   	push   %ecx
  11:	83 ec 18             	sub    $0x18,%esp
	int i, j, ans_idx = 0;
	for(i = 0; i < NR_DATA; i ++) {
		for(j = 0; j < NR_DATA; j ++) {
  14:	31 db                	xor    %ebx,%ebx
	for(i = 0; i < NR_DATA; i ++) {
  16:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  1d:	8d 76 00             	lea    0x0(%esi),%esi
			nemu_assert(add(test_data[i], test_data[j]) == ans[ans_idx ++]);
  20:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  23:	8b 34 85 00 00 00 00 	mov    0x0(,%eax,4),%esi
		for(j = 0; j < NR_DATA; j ++) {
  2a:	31 ff                	xor    %edi,%edi
			nemu_assert(add(test_data[i], test_data[j]) == ans[ans_idx ++]);
  2c:	83 ec 0c             	sub    $0xc,%esp
	int c = a + b;
  2f:	8b 14 bd 00 00 00 00 	mov    0x0(,%edi,4),%edx
  36:	01 f2                	add    %esi,%edx
			nemu_assert(add(test_data[i], test_data[j]) == ans[ans_idx ++]);
  38:	3b 94 bb 00 00 00 00 	cmp    0x0(%ebx,%edi,4),%edx
  3f:	0f 94 c2             	sete   %dl
  42:	0f b6 d2             	movzbl %dl,%edx
  45:	52                   	push   %edx
  46:	e8 fc ff ff ff       	call   47 <main+0x47>
  4b:	83 c4 10             	add    $0x10,%esp
		for(j = 0; j < NR_DATA; j ++) {
  4e:	47                   	inc    %edi
  4f:	83 ff 08             	cmp    $0x8,%edi
  52:	75 d8                	jne    2c <main+0x2c>
		}
		nemu_assert(j == NR_DATA);
  54:	83 ec 0c             	sub    $0xc,%esp
  57:	6a 01                	push   $0x1
  59:	e8 fc ff ff ff       	call   5a <main+0x5a>
  5e:	83 c4 10             	add    $0x10,%esp
	for(i = 0; i < NR_DATA; i ++) {
  61:	ff 45 e4             	incl   -0x1c(%ebp)
  64:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  67:	83 c3 20             	add    $0x20,%ebx
  6a:	83 f8 08             	cmp    $0x8,%eax
  6d:	75 b1                	jne    20 <main+0x20>
	}

	nemu_assert(i == NR_DATA);
  6f:	83 ec 0c             	sub    $0xc,%esp
  72:	6a 01                	push   $0x1
  74:	e8 fc ff ff ff       	call   75 <main+0x75>
  79:	83 c4 10             	add    $0x10,%esp

	return 0;
}
  7c:	31 c0                	xor    %eax,%eax
  7e:	8d 65 f0             	lea    -0x10(%ebp),%esp
  81:	59                   	pop    %ecx
  82:	5b                   	pop    %ebx
  83:	5e                   	pop    %esi
  84:	5f                   	pop    %edi
  85:	5d                   	pop    %ebp
  86:	8d 61 fc             	lea    -0x4(%ecx),%esp
  89:	c3                   	ret    
